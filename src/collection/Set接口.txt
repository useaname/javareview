Set接口。
Set集合类似于一个罐子，一旦把对象对象丢尽Set集合，集合里多个对象之间就没有明显的顺序。Set集合和Collection基本上完全一样，没有提供额
外的方法。实际上Set就是Collection。只是行为不同，（Set不允许包含重复元素）。

Set集合不允许包含相同的元素，如果试图把两个相同元素加入同一个Set集合中，则添加操作失败，add方法返回false，且新元素不会被加入。
Set判断两个对象相同不是使用==运算符，而是根据equals方法。

HashSet类。
HashSet是Set接口的典型实现，大多数是哦那个Set集合就是使用这个实现类。HashSet是按Hash算法来存储集合中的元素。因此具有很好的查找
和存取性能。
HashSet具有以下特点:
--》不能保证元素排列的顺序，顺序有可能发生变化。
--》HashSet不是同步的，如果有多个线程同时访问一个HashSet，如果有2条或者2条以上线程同时修改HashSet集合时，必须通过代码来保证其同步。
--》集合元素值可以是null。

当向HashSet集合中存入一个元素时，HashSet会调用该对象的HashCode()方法来得到该对象的hashCode值，然后根据该HashCode值来决定该
对象在HashSet中的存储位置。如果有两个元素通过equals方法比较返回true。但他们的HashCode()返回值不相等，HashSet将会把他们存储在
不同位置，也就可以添加成功。
简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。

如果需要把一个对象放入HashSet中时，如果重写该对象对应类的equals方法，也应该重写其hashCode方法 。其规则是：如果两个对象通过equals
方法比较返回true，这两个对象的hashCode也应该相同。

HashCode方法对于HashSet的作用是什么？
先要理解hash(也被翻译为哈希，散列)算法的功能：它能保证通过一个对象快读查找到另一个对象。hash的价值在于速度，它可以保证查询得到快速执行。
当需查询集合中某个元素时，hash算法可以很直接根据该元素的值的到该元素保存在何处，从而让程序快读找到该元素。为了理解这个概念，先看数组（数组
是所有能存储一组元素里最快的结构）：数组可以包含多个元素，每个元素也有索引，如果要访问某个数组元素，只需提供该元素的索引，该索引指出了该元素
在数组呢村区里的存储位置。
表面上看来，HashSet集合里的元素没有索引，实际上当程序向HashSet集合中添加元素时，HashSet会根据该元素的hashCode值来决定它的存储位置,
也就是说每个元素的hashCode就是它的索引。
为什么不直接使用数组，还需要使用HashSet呢？因为数组的元素的索引是连续的，而且数组的长度是固定的，无法自由增加数组的长度。而HashSet就不
一样了，采用每个元素的hashCode值作为索引，从而可以自由的增加数组长度。并可以根据元素的hashCode值来访问元素。因此当从HashSet中访问
元素时，HashSet先计算该元素的hashCode，然后直接到该hashCode所对应的位置去取出元素，这就是HashSet访问速度很快的原因。

HashSet中每个能存储元素的“槽位(slot)”通常称为“桶(bucket)”,如果有多个元素的hashCode相同，但他们通过equals方法比较返回false，
就需要在一个桶里放多个元素，从而导致性能下降。

重写hashCode的基本规则：
--》当两个对象通过equals方法比较返回true，这两个hashCode应该相等。
--》对象中用作equals比较标准的 属性，都应该来计算hashCode值。

HashSet还有一个子类LinkedHashSet,也是根据元素hashCode值来决定元素存储位置，同时使用链表维护元素次序，使得元素看起来是以插入顺
序保存的，便利LinkedHashSet会按元素的添加属性怒来访问集合中的元素。性能略低于HashSet，但在迭代时将有很好的性能，因为它以链表来
维护内部顺序。

