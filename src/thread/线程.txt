线程的运行状态
新建 就绪 阻塞 运行 死亡
实现多线程的两种方式:1.继承Thread 2.实现Runnable接口
发生如下情况，线程将进入阻塞状态:
线程调用sleep方法主动放弃所占用的处理器资源
线程调用了一个阻塞式的IO方法，在该方法返回前，该线程被阻塞
线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有
线程正在等待某个通知(notify)
程序调用了线程的suspend方法将挂起，不过这个方法将很容易导致死锁，所以程序应该尽量避免使用该方法

针对上面几种情况，当发生如下特定的情况可以解除上面的阻塞，让线程重新进入就绪状态：
调用sleep方法的线程已经过了指定的时间
线程调用的阻塞IO方法已经返回
线程成功地获得了试图取得同步监视器
线程正等待某个通知时，其他线程发出来一个通知
处于挂起状态的线程被调用了resume方法

线程死亡
线程会以以下三种方式之一结束，结束后就处于死亡状态
run方法执行完成，线程被正常结束
线程抛出一个未捕获的Exception或Error
直接调用该线程的stop()方法来结束该线程-该方法很容易导致死锁，通常不推荐使用

当主线程结束的时候，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，不会受到主线程影响
