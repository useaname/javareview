在外部类内使用内部类：
  不要在外部类的静态成员（包括静态方法和静态初始化块）中使用非静态内部类，因为静态成员不能访问非静态成员。
在外部类内部定义内部类的子类与平常定义子类没太大区别。

在外部类以外使用非静态内部类：
  如果希望在外部类意外的地方访问内部类（包括静态和非静态两种），则内部类不能使用private访问控制权限，private
 修饰的的内部类只能在外部类内使用。对于使用其他访问控制修饰符的内部类，则能在访问控制符对应的访问控制权限内使用：
	--》省略访问控制修饰符的类，只能被与外部类处于同一个包中其他类所访问。
	--》使用protected修饰的内部类：可在任何地方被访问。
	--》使用public修饰的内部类：在任何地方被访问。
在外部类以外的地方来定义内部类(包括静态和非静态两种)语法格式如下：
OuterClass.InnerClass varName

在外部类以外的任何地方使用内部类时，内部类完整的类名应该是OutClass.InnerClass。当然外部类如果有包名。则还应该增加包名的前缀。
因为非静态内部类的对象必须寄存在外部类的对象里，因此创建非静态内部类对象之前，必须先要创建其他外部类对象。在外部类意外的地方创建非静态内部类
实例的语法如下：
OuterInstance.new InnerConstructor();
在外部类以外的地方创建非静态内部类实例必须使用外部类实例和new来调用非静态内部类的构造器。

 *下面代码创建非静态内部类的对象
 *非静态内部类的构造器必须使用外部类对象来调用 
 
当创建一个子类时，子类构造器总会调用父类的构造器，因此在创建非静态内部类子类时，必须保证让子类构造器可以调用非静态内部类的构造器，调用非
静态内部类的构造器时，必须存在一个外部类对象。

非静态内部类的子类不一定是内部类，它可以是一个顶层类。但非静态内部类。但非静态内部类的子类的实例一样需要保留一个引用，该引用指向其父类，所在
外部类的对象。也就是说，如果有一个内部子类的对象存在，则一定存在与之对应外部类对象。
在外部类意外的地方创建静态内部类实例的语法如下：
new OuterClass.InnerConstructor()

不管是内部类还是静态内部类，还是非静态内部类，它们声明变量的语法完全一样。
区别只是在创建内部类对象时，前者只需使用外部类来调用构造器，而后者必须使用外部类对象来调用构造器。

定义一个静态内部类时，其外部类非常向一个包空间。

既然内部类时外部类的成员，是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部类？
不可以。内部类的类名不再是简单的由内部类的类名组成，它实际上还把外部类名作为一个命名空间，作为内部类类名的限制。
因此子类中内部类和父类中的内部类不可能完全同名，即使二者所包含的内部类的类名相同，但因为它们所处外部类空间不同，
所以不可能是同一个类。也就不能重写。
