内部类。某些情况下，把一个类放在另一个类的内部定义，这个定义在其他类内部类就被称为内部类（也被称为嵌套类）。包含内部类的类被称为外部类，也
被称为宿主类。 
内部类的作用：
--》内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包的其他类访问该类。
--》内部类成员可以直接访问外部类私有数据，因为内部类被当成其外部类成员，同一个类的成员之间可以相互访问。
--》匿名内部类适用于创建哪些仅需要一次使用的类。

public class OuterClass{
	//此处定义内部类
}

大部分时候  内部类作为成员内部类定义，而不是作为局部内部类。成员内部类是一种与属性，方法，构造器和初始化块相似的类成员。局部内部类和匿名内部类则不是
类成语。

成员内部类
 |-- 静态内部类  static修饰的成员内部类是静态内部类
 |-- 非静态内部类 非static修饰的成员内部类

非静态内部类里可以直接访问外部类private成员。这是因为在非静态内部类的对象里，保存了一个它（非静态内部类）寄存在外部类对象的引用（当调用非静态内部类的实例方法时，
必须有一个非静态内部类的实例，而非静态内部类实例必须寄存在外部类实例里）。

在非静态内部类的方法内访问某个变量时，系统优先在该方法内查找是否存在该名字的局部变量，如果存在，就使用该变量；如果不存在则到该方法所在的内部类中查找
是否 存在该名字的属性，如果存在则使用该属性；如果不存在则到该内部类所在的外部类中查找是否存在该名字的属性，如果存在则使用，如果不存在将出现编译错误，
提示找不到变量。
外部类属性：外部类类名.this.属性名
内部类属性:this.属性名
局部变量:局部变量名

非静态内部类的成员可以访问外部类的private成员，反过来就不成立了。非静态内部类的成员在非静态内部类范围是可知的，并不能被外部类直接调用。
如果外部类需要访问非静内部类的成员，必须显示的创建非静态内部类对象来调用访问其实例成员。

非静态内部类对象和外部类对象的关系：
 非静态内部类对象必须寄存在外部类对象里，而外部类对象则不必一定有非静态内部类对象寄存其中。简单的说，如果存在一个非静态内部类独享，则一定存在
 一个被它寄存的外部类对象。但外部类对象存在时，外部类对象不一定寄存了非静态内部类独享。因为外部类对象访问非静态内部类成员时，可能普通内部类对
 象根本不存在。而非静态内部类对象访问外部类成员时，外部类对象是一定存在的。

根据静态成员不能访问非静态成员的规则，外部类的静态方法，静态代码块，不能访问非静态内部类，包括不能 使用非静态内部类的定义变量，创建实例等。总之，
不允许在外部类的静态成员中直接使用非静态内部类。

Java不允许在非静态内部类里定义静态成员。(非静态内部类不能有静态方法，静态属性，静态初始化块)

非静态内部类里不可以有静态初始化块，但可以包含普通初始化块。非静态内部类普通初始化块的作用与顶层类初始化块的作用完全相同。

静态内部类。使用static修饰一个内部类，这个内部类变成外部类类相关的，属于整个外部类。而不是单独的属于某个外部类的对象。因此使用static修饰
内部类被称为类内部类，有的地方也被称为静态内部类。


static关键字的作用是把类成员变成类相关，而不是实例相关。即static修饰成员是属于整个类，而不是属于单个对象。外部类的上一级程序单元是包，所以
不可使用static修饰。而内部类的上一级程序单元是外部类，使用static关键字修饰可以将内部类变成外部类相关，而不是外部类实例相关。因此static
关键字不可修饰外部类，可以修饰内部类。

静态内部类可以包含静态成员，也可以包含非静态成员。根据静态成员不能访问非静态成员的规则，所以静态内部类不能访问外部类的实例成员，只能外部类的
类成员。即使静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的类成员。

为什么静态内部类实例方法不能访问外部类的实例属性
因为静态内部类是外部类相关，而不是外部类的对象相关的。也就是说，静态内部类的对象不是寄存在外部类对象里，而是寄存在外部类的类本身中。
也就是说当静态内部类的对象存在时，并不 存在一个被它寄存的外部类对象，静态内部类的对象里只有外部类来的引用，没有外部类对象的引用。如果
允许静态内部类的实例方法访问外部类的实例尘缘时，但找不到被寄存的外部类对象，这将引起错误。

Java允许在接口里定义内部类，接口里定义的内部类默认使用public static 修饰，也就是说接口内部类只能是静态内部类。该内部类默认是public访问
控制符。

接口里能否定义内部接口？
可以。接口里的内部接口 是接口的成员。因此被系统默认添加public static修饰符，如果定义接口内部接口时指定访问修饰符，只能是public。当然
接口里定义内部接口的意义并不大。因为接口的作用是定义一个公共的规范。 （暴露出来给大家使用），如果把这个接口定义成内部接口，那么意义何在呢？


