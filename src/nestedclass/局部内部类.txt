局部内部类，如果把一个类放在方法里定义，则这个内部类就是一个局部内部类。局部内部类仅在该方法里有效。因此局部内部类不能在类以外的
地方使用，那么局部内部类也无需使用访问控制符和static修饰符修饰。

对于局部成员而言，不管是局部变量，还是局部内部类，他们的山以及程序单元是方法，而不是类。因此所有局部成员都不能使用static修饰，不仅如此
，因为局部成员的作用域是所在方法，其他程序单元永远不可能访问另一个方法中的局部成员，所以所有局部成员都不能使用访问控制修饰符。

内部类的class文件名总是遵循如下命名格式：OuterClass$NInnerClass.class
局部内部类的class文件的文件名比成员内部类的class文件的文件名多了一个数字，这是因为同一个类里不可能有两个同名的成员内部类，而同一个类
里则可能有两个以上同名的局部内部类（处于不同的方法中），所以Java为局部内部类的class文件中增加一个数字，用于区分。

匿名内部类。
匿名内部类适合创建那种只需要一次使用的类，创建匿名内部类类时会立即创建一个该类的实例，这个类定义立即消失，匿名内部类不能重复使用。
定义内部类的格式如下：

 new 父类构造器(实参列表)|实现接口(){
	//匿名内部类的类体部分
 }
 
 从上面可以看出，匿名内部类必须继承一个父类，或者实现一个接口，但最多只能继承一个父类或者实现一个接口。
 匿名内部类还有如下两条规则：
 --》匿名内部类不能是抽象类，因为系统在创建匿名内部类的时候，会立即创建匿名内部类的对象。因此不允许将匿名内部类定义成抽象类。
 --》匿名内部类不能定义构造器，因为匿名内部类没有类名，所以发发定义构造器，但匿名内部类可以定时初始化块，通过实例初始化块来
 完成构造器需要完成的事情。

类可以定义实例初始化块，通过实例初始化块来完成构造器需要完成的事情。
最常用的创建匿名内部类的方式是需要创建某个接口类型的对象。

当通过实现接口来创建匿名内部类时匿名内部类也不能显式创建构造器，因此匿名内部类只有一个隐私的无参构造器，故new接口名后的括号里
不能传入参数值。
 
但如果通过继承父类来创建 匿名内部类时，匿名内部类将拥有和父类相似的构造器，此处相似指的是拥有相同的形参列表。

当创建匿名内部类时，必须实现接口或抽象父类里所有的抽象方法。如果有需要，也可以重写父类中的普通方法。
如果匿名内部类需要访问外部类的局部变量，则必须使用final修饰符来修饰外部类的局部变量，否则系统将会报错。 
