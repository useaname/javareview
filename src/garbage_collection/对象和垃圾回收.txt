Java的垃圾回收是Java语言重要功能之一。当程序创建对象，数组引用理性实体时，系统都会在堆内存中为之分配一块内存区，对象就保存这块内存区中，这块
 内存不再被任何引用变量引用时，这块内存就变成垃圾。等待垃圾回收机制进行收回。垃圾回收机制具有如下特征：
--》垃圾回收机制只能负责回收堆内存中对象，不会回收任何物理资源(例如数据库连接，网络IO等资源)。
--》程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久性失去引用后，系统就会在合适时候回收它所占的内存。
--》垃圾回收机制回收任何对象之前，总会调用finalize方法，该方法可能使该对象 重新复活（让一个引用变量重新引用该对象），从而导致垃圾回收机制
取消回收。


对象在内存中的状态。当一个对象在堆内存中运行时，根据被引用变量所引用的状态，可以把它当状态分成如下三种：
--》激活状态:当一个对象被创建后，有一个以上的引用变量引用它，则这个对象在程序中处于激活状态，程序可以通过引用变量来调用该对象的属性和方法。
   （可触及状态:当一个对象被创建后，只要程序中还有引用变量引用它，那么它就始终处于可触及状态。）
--》去活状态(可复活状态):如果程序中某个对象不再有任何引用变量引用它，它就进入了去活状态。在这个状态下，系统的垃圾回收机制准备回收该对象所
占用的内存，在回收该对象之前，系统会调用所有去活对象的finalize方法进行资源清理，如果系统在调用finalize方法重新让一个引用变量引用该对
象，则这个对象会再次变为激活状态；否则该对象进入死亡状态。
--》死亡状态:当对象与所有引用变量的关联都被切断，且系统在调用finalize方法依然没有是该对象编程激活状态，那这个对象将永久性地失去引用，最
后变成死亡状态。只有当一个对象处于死亡状态时，系统才会正真回收该对象所占用的资源。

一个对象可以被一个方法局部变量引用，也可以被其他类属性引用，或被其他对象的实例为属性引用。当某个对象被其他类属性引用时，只有该类被销毁后，该对
象才会进入去活状态；当某个对象被其他对象的实例属性引用时，只有当该对象被销毁后该对象才会进去去活状态。

强制垃圾回收。当一个对象失去引用后，系统合何时调用它的finalize方法进行资源清理，何时它会变成死亡状态，系统何时回收它所占有的内存，对于程序
完全透明。程序只能控制一个对象何时不再被任何引用变量引用，绝不能控制它何时被回收。
程序发发精确控制Java垃圾回收的时机，但我们依然可以强制系统进行垃圾回收，--只是这种强制回收只是通知系统进行垃圾回收，但系统是否进行垃圾回收
依然不确定，大部分时，程序强制系统垃圾回收后总有一些效果，强制系统垃圾回收有如下两个办法。：
--》调用System类的gc()静态方法。System.gc()
--》调用Runtime对象的gc()实例方法。Runtime.getRuntime.gc()


finalize方法。
当垃圾回收机制回收某个对象所占用的内存之前。通常要求程序调用适当的方法来清理资源，在没有明确指定资源清理情况下，Java提供了默认机制来清理该
对象的资源，这个方法就是finalize。
该方法是定义在Object类的实例方法。方法原型为
protected void finalize() throws Throwable
当finalize()方法返回之后，对象消失，垃圾回收机制开始执行。方法原型中的throws Throwable表示它可以抛出任何异常。

任何Java类都可以覆盖Object类的finalize方法，在该方法中清理该对象占用的资源。如果程序终止前没有进行垃圾回收，则不会调用失去引用对象
的finalize方法来清理资源。